Index: CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>cmake_minimum_required(VERSION 3.22.1)  # CMake version check\r\nproject(Backerup)               # Create project \"simple_example\"\r\nset(CMAKE_CXX_STANDARD 17)            # Enable c++17 standard\r\n\r\nset(includes includes/inputmanager.h includes/vaultmanager.h includes/configmanager.h)\r\nset(sources Backerup.cpp InputManager.cpp VaultManager.cpp ConfigManager.cpp)\r\nadd_library(tinyxml2 STATIC dependencies/tinyxml2/tinyxml2.cpp dependencies/tinyxml2/tinyxml2.h)\r\n\r\nadd_executable(Backerup ${sources} ${includes})\r\ntarget_link_libraries(Backerup tinyxml2)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	(revision aef89c827888d481c062de9a4b60d5081f2cee24)
+++ b/CMakeLists.txt	(date 1641973895310)
@@ -1,4 +1,4 @@
-cmake_minimum_required(VERSION 3.22.1)  # CMake version check
+cmake_minimum_required(VERSION 3.21.1)  # CMake version check
 project(Backerup)               # Create project "simple_example"
 set(CMAKE_CXX_STANDARD 17)            # Enable c++17 standard
 
Index: VaultManager.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <ctime>\r\n#include <fstream>\r\n#include <iostream>\r\n#include <filesystem>\r\n#include \"includes\\tinyxml2.h\"\r\n#include \"includes\\configmanager.h\"\r\n#include \"includes\\vaultmanager.h\"\r\n\r\n    VaultManager::VaultManager(ConfigManager *manager)\r\n    {\r\n        configManager = manager;\r\n        vaultPath = configManager->getConfig(ConfigManager::configOptions::vaultPath);\r\n        vaultXML = new tinyxml2::XMLDocument();\r\n        //If XML file does not exist: create a new file\r\n        if (!std::filesystem::exists(vaultPath.string() + \"vault.xml\"))\r\n        {\r\n            std::cout << \"Could not find XML file inside Vault.\\nCreating new.\" << std::endl;\r\n            std::fstream *vaultFile = new std::fstream();\r\n            vaultFile->open(vaultPath.string() + \"vault.xml\");\r\n            vaultFile->close();\r\n            //TODO: Populate newly created XML file with root node\r\n        }\r\n        vaultXML->LoadFile((vaultPath.string() + \"vault.xml\").c_str()); //TODO: Might not work\r\n        rootXML = vaultXML->RootElement();\r\n    }\r\n        //Backup a file with path or file object\r\n            //Returns negative if failed; else the file's ID number\r\n    int VaultManager::fileBackup(std::filesystem::path file)\r\n    {\r\n        std::filesystem::path qualifiedPath =\r\n            configManager->getConfig(ConfigManager::configOptions::vaultPath) +\r\n                file.filename().string();\r\n        int backupID;\r\n        std::error_code *copyError = new std::error_code();\r\n        try\r\n        {\r\n            while(std::filesystem::exists(qualifiedPath))\r\n            {\r\n                std::cout << \"Designated file already exists in registry.\\n\" <<\r\n                    \" File with be backed up designated as 'copy'.\" << std::endl;\r\n                qualifiedPath = qualifiedPath.string() + \".copy\" + qualifiedPath.extension().string();\r\n                //TODO: Does this work? lol Update: Yes it does kekw\r\n                //TODO: Remove these clutter comments omegalol\r\n                //TODO: Make recursive copies appear as one notice\r\n            }\r\n            std::filesystem::copy(file, qualifiedPath);\r\n            std::cout << \"File '\"\r\n                << file.filename().string()\r\n                << \"' has been backed up to:\\n\"\r\n                << configManager->getConfig(ConfigManager::configOptions::vaultPath)\r\n                << std::endl;\r\n\r\n            //Log this backup in XML file\r\n            backupID = getFirstAvailableID();\r\n            logBackup(backupID, file, file.filename().string());\r\n\r\n            std::cout << file.filename().string()\r\n                << \" has been assigned ID \"\r\n                << backupID << std::endl;\r\n        }\r\n        catch(const std::exception& e)\r\n        {\r\n            std::cerr << e.what() << '\\n';\r\n            return -1;\r\n        }\r\n\r\n        return backupID;\r\n    }\r\n\r\n        //Get a file with string- or integer identifier\r\n    void VaultManager::fileRetrieve(std::string identifier)\r\n    {\r\n        tinyxml2::XMLElement *file = rootXML->FirstChildElement(\"file\");\r\n        while(file != NULL)\r\n        {\r\n            //Check this file's name against the provided filename\r\n            if (strcmp(identifier.c_str(), file->FirstChildElement(\"fileName\")->GetText()) == 0)\r\n                break;\r\n            file = file->NextSiblingElement();\r\n        }\r\n        if (file == NULL)\r\n        {\r\n            std::cout << \"We could not find \" << identifier\r\n                << \" in the vault. Use 'query' to search.\"\r\n                << std::endl;\r\n            return;\r\n        }\r\n        else\r\n        {\r\n            //Attempt to move the found file to where it was called from\r\n            std::string qualifiedPath =\r\n                configManager->workingDirectory() + file->FirstChildElement(\"fileName\")->GetText();\r\n            if (std::filesystem::exists(qualifiedPath))\r\n            {\r\n                std::cout << \"File with same name already exists.\\n\"\r\n                    << \"File will be retrieved as 'backup.file'\" << std::endl;\r\n                qualifiedPath = \"backup.\" + qualifiedPath;\r\n                if (std::filesystem::exists(qualifiedPath))\r\n                {\r\n                    int iterator = 1;\r\n                    while(std::filesystem::exists(std::to_string(iterator) + qualifiedPath))\r\n                    {\r\n                        iterator++;\r\n                    }\r\n                    qualifiedPath = std::to_string(iterator) + qualifiedPath;\r\n                }\r\n            }\r\n            try\r\n            {\r\n                std::filesystem::copy(\r\n                    file->FirstChildElement(\"filePath\")->GetText(),\r\n                    qualifiedPath\r\n                );\r\n            }\r\n            catch(const std::exception& e)\r\n            {\r\n                std::cerr << \"Could not retrieve the file: \\n\";\r\n                std::cerr << e.what() << std::endl;\r\n            }\r\n        }\r\n    }\r\n    void VaultManager::fileRetrieve(int identifier)\r\n    {\r\n\r\n    }\r\n        //Return whether a file matches specified query\r\n            //Can return all close-matching results (optional)\r\n    std::FILE fileQuery(std::string query);\r\n    std::FILE* fileQuery(std::string query, bool similar);\r\n        //TODO: Add code\r\n\r\n    ConfigManager *configManager;\r\n    std::filesystem::path vaultPath;\r\n    tinyxml2::XMLDocument *vaultXML;\r\n    tinyxml2::XMLElement *rootXML;\r\n\r\n    void VaultManager::logBackup(int id, std::filesystem::path filePath, std::string fileName)\r\n    {\r\n        tinyxml2::XMLElement *newBackup = vaultXML->NewElement(\"file\");\r\n        newBackup->InsertNewChildElement(\"id\")->InsertNewText(std::to_string(id).c_str());\r\n        newBackup->InsertNewChildElement(\"fileName\")->InsertNewText(fileName.c_str());\r\n        newBackup->InsertNewChildElement(\"filePath\")->InsertNewText(filePath.string().c_str());\r\n        time_t currentTime = time(0);\r\n        newBackup->InsertNewChildElement(\"fileBackupDate\")->InsertNewText(ctime(&currentTime));\r\n        rootXML->LinkEndChild(newBackup);\r\n        vaultXML->SaveFile((vaultPath.string() + \"vault.xml\").c_str());\r\n    }\r\n    int VaultManager::getFirstAvailableID()\r\n    {\r\n        int id = 0;\r\n        tinyxml2::XMLElement *element = rootXML->FirstChildElement(\"file\");\r\n        if (element == NULL)\r\n            return id;\r\n        bool available = false;\r\n        while(!available)\r\n        {\r\n            available = true;\r\n            while(element != NULL)\r\n            {\r\n                if(element->FirstChildElement(\"id\")->GetText() == std::to_string(id))\r\n                {\r\n                    available = false;\r\n                    break;\r\n                }\r\n                element = element->NextSiblingElement();\r\n            }\r\n            if (!available)\r\n                id++;\r\n        }\r\n\r\n        return id;\r\n    }
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/VaultManager.cpp b/VaultManager.cpp
--- a/VaultManager.cpp	(revision aef89c827888d481c062de9a4b60d5081f2cee24)
+++ b/VaultManager.cpp	(date 1641973802271)
@@ -17,6 +17,7 @@
             std::cout << "Could not find XML file inside Vault.\nCreating new." << std::endl;
             std::fstream *vaultFile = new std::fstream();
             vaultFile->open(vaultPath.string() + "vault.xml");
+            vaultFile->write("<vault>\n</vault>", 17);
             vaultFile->close();
             //TODO: Populate newly created XML file with root node
         }
